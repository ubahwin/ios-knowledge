## Содержание

- [swift](#swift)
  - [Комментарии](#комментарии)
  - [Переменные, константы, кортежи](#переменные-константы-кортежи)
  - [Типы данных](#типы-данных)
    - [Основные](#основные)
    - [Opaque return types](#opaque-return-types)
  - [Операции](#операции)
  - [Условия](#условия)
  - [Циклы](#циклы)
  - [Функции](#функции)
  - [Классы, структуры, перечисления](#классы-структуры-перечисления)

# swift

**swift** – компилируемый, чистый объектно-ориентированный язык программирования со строгой типизацией.

Полностью совместим с Cocoa API (основной API для macOS)

## Комментарии

```swift
/*
Это
Комментарий
*/

// Это Комментарий
```

## Переменные, константы, кортежи

*Variable* – переменная:
```swift
var name: String = "Ivan" 
```

Константа:

```swift
let name: String = "Ivan"
```

Кортеж:

```swift
let info: (String, Int) = ("Ivan", 20)
```

## Типы данных

Типы данных являются структурами и классами, поэтому можно сделать даже так: `1.description`, `"Ivan".lowercased()`

### Основные

- `Int` – целочисленные (`Int64` ∈ [-9 * 10^8, 9 * 10^8])
- `Double` – плавающая точка
- `String` – строка
- `Character` – символ
- `Bool` – `true` or `false`

Опциональные типы:

`Optional<тип>` – может не иметь значение, но все ещё строго типизирован.

```swift
let a: Int? = nil
a = 20
```
`Optional<Int>` то же самое, что и `Int?`
Чтобы извлеч значение `Int` из `Int?` нужен оператор `!` при не `nil` значении, если в этом нет уверенности, то используем `?? (значение при nil)`:

```swift
let b = a ?? 10
```

### Opaque return types

Непрозрачные типы – с swift 5.1

Функция или свойство с `some` позволяет возвращать неконкретный тип (тип протокола). Тем самым *скрывается* тип, который возвращается в функции, сохраняя его *идентичность*.

```swift
protocol Person { var name: String }

struct Man: Person { var name: String }

func makeIvan() -> some Person {
    return Man(name: "Ivan")
}
```

Чаще всего используется, когда надо дать возможность собирать что-то из "блоков", например как в `View` в [SwiftUI](swiftui/README.md)

## Операции

`+ - * /` – сложение, вычитание, умножение, деление
`%` – остаток от деления
`-` – унарный минус (`var a = -6; var b = -a // 6`)
Разрешено делать `+= -= ...`


`&` – логическое умножение:
```swift
let a = 6       // 110
let b = 5       // 101
let c = a & b   // 100 = 4
```
`|` – логическое `ИЛИ`
`^` – исключающее `ИЛИ`
`~` – инверсия
`<< >>` – сдвиг влево, сдвиг вправо

`=` – приравнивание
`==` – равенство
`!=` – неравенство
`> >= < <=` – сравнения

`!` – инверсия `Bool` значения
`&&` – логическое `И`
`||` – логическое `ИЛИ`

## Условия

```swift
if логическое условие {
    код
} else {
    код иначе
}
```
Тернарный:
```swift
условие ? код : код иначе
(a > b) ? (b + 1) : (a - b)
```

Переключение по условиям:

```swift
switch переменная {
    case условие: код
    case условие: код
    default: код, если не прошло ни по одному условию
}
```

## Циклы

**for-in**

```swift
for объект последовательности in последовательность where условие выборки {
    код
}
```

Можно задать последовательность так: `0..<6`

**while**

```swift
while условие {
    код
}
```

`break` – выход из цикла
`continue` – переход на следующую итерацию

## Функции

```swift
func имя(параметры входящие) -> тип возвращаемого значения {
    код
    return значение
}
```

```swift
func fullInfo(with name: String, age: inout Int) -> String {
    return name + " \(age)"
}
var a = 20
print(fullInfo(with: "Ivan", age: &a))
```
Функция возвращает полную информацию в строке, принимает через слово `with` имя типа `String`, и `age` типа ссылки (`inout`) на `Int`


- Функция, которая ничего не возвращает эквивалентна `func name() -> Void { }` или `func name() -> () { }`
- Функция может вернуть несколько значений только в виде кортежа

## Классы, структуры, перечисления

| Reference types | Value types |
|-|-|
| `class` | `struct`, `enum`, *tuple* | 



**Свойства**

> Существует 2 типа свойств:
> - Хранимые (*stored properties*) – только классы и структуры.
> - Вычисляемые (*computed properties*)

Хранимые могут быть `lazy`, то есть будут установлены при первом обращении к ним.

`Сomputed` динамически вычисляют значения через `get`, `set`

Динамические свойства бывают *read-only*, то есть имеют только блок `get`: 
```swift
var fullName: String {
    return self.firstName + self.secondName
}
```

**Наблюдатели свойств**

- `willSet(новый параметр)` 
- `didSet(старый параметр)`

**mutating**

Так как структуры и перечисления это значения, а не ссылки, как классы, то по умолчанию свойства значений нельзя менять. Однако изменить свойства структуры можно с помощью `mutating`. `mutating` используется в определениях методов.

`static` свойства и методы называются *свойствами и методами типа* (`Type.property`)

Свойства в перечислениях (`case Man(String)`, затем `case .Man(let name): ...`) называются *ассоциированными значениями*
У перечислений так же есть и *чистые значения* (`case Man = "Ivan"`)
Перечисления могут иметь методы, но не могут иметь хранимых свойств, а только динамические:
```swift
var title: String {
    switch self {
        case .Man: return "Ivan"
        case .Woman: return "navI"
    }
}
```

`super` позволяет обращаться к свойствам и методам базового класса из дочернего

Чтобы переопределить метод или свойство или инициализатор у базового класса, от которого наследован текущий, можно написать `override`

Если нужно, чтобы нельзя было переписать через `override` инициализатор, можно написать `required`, `final` может наложить запрет на переопределение у методов и свойств

*Динамическая диспетчеризация* – прием, при котором система выбирает реализацию одного метода (`полиморфизм`)
